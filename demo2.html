<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Light Map Generation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
		<style>
			html, body {
				width: 100%;
				height: 100%;
				font-family: Monospace;
				background-color: #000;
				color: #000;
				margin: 0px;
				overflow: hidden;
			}
			
			#info {
				position: absolute;
				top: 5px;
				width: 100%;
				text-align: center;
				color: #ffffff;
			}		
			
		</style>
	</head>
	<body>

		<div id="container"> </div>
		<script src="js/three.min.js"> </script>
		<script src="js/pathTracingCommon.js"> </script>
		<script src="js/EditorControls.js"> </script>
	</body>

	<script id="vertexShader" type="x-shader/x-vertex">

		varying vec2 lightTexCoord;
		varying vec3 vPosition;
		varying vec3 vNormal;

		void main(){

			vPosition = position;
			vNormal = normal;
			gl_Position = vec4(uv2.x / 2 - 1, uv2.y / 2 - 1 , 0., 1.);

		}
	</script>
	<script id="fragmentShader" type="x-shader/x-fragment">


		varying vec2 lightTexCoord;
		varying vec3 vPosition;
		varying vec3 vNormal;

		struct Ray { vec3 origin; vec3 direction; };

		#define QUAD_COUNT 5

		#define PI               3.14159265358979323
		#define TWO_PI           6.28318530717958648
		#define FOUR_PI          12.5663706143591729
		#define ONE_OVER_PI      0.31830988618379067
		#define ONE_OVER_TWO_PI  0.15915494309
		#define ONE_OVER_FOUR_PI 0.07957747154594767
		#define PI_OVER_TWO      1.57079632679489662
		#define ONE_OVER_THREE   0.33333333333333333
		#define E                2.71828182845904524
		#define INFINITY         1000000.0

		vec3 cosWeightedRandomHemisphereDirection( const vec3 n );

		float castRay( vec3 ro, vec3 rd, out vec2 uv, out vec3 col, out vec3 n )
		{
		    uv = vec2(0.); n = uv.xxx;
		    
		    float rt = DIST_MAX;
		    for( int i = 0; i < QUAD_COUNT; i++ )
		    {
		        vec2 uvi; float rti;
		        if( rayQuadUV( ro, rd, quads[i].p, quads[i].n, quads[i].scl, uvi, rti ) 
		          && rti < rt )
		        {
		            uv = quads[i].uv_c + (uvi-.5)*quads[i].uv_wh;
		            col = GetColor(quads[i].col);
		            n = quads[i].n;
		            rt = rti;
		        }
		    }
		    
		    return rt;
		}

		struct Wall {
			vec3[] position;
			vec3[] normal;
			int[] index;
		}

		
		//---------------------------------------------------------
		float TriangleIntersect( vec3 v0, vec3 v1, vec3 v2, Ray r )
		//---------------------------------------------------------
		{
			vec3 edge1 = v1 - v0;
			vec3 edge2 = v2 - v0;
			vec3 tvec = r.origin - v0;
			vec3 pvec = cross(r.direction, edge2);
			float det = 1.0 / dot(edge1, pvec);
			float u = dot(tvec, pvec) * det;

			if (u < 0.0 || u > 1.0)
				return INFINITY;

			vec3 qvec = cross(tvec, edge1);

			float v = dot(r.direction, qvec) * det;

			if (v < 0.0 || u + v > 1.0)
				return INFINITY;

			return dot(edge2, qvec) * det;
		}


		void main(){


			for( int i = 0; i < INDIRECT_RAYS; i++ )
		    {
		        // from https://www.shadertoy.com/view/4tcXD2
		        // doesn't need pdf term - cancels out: http://www.rorydriscoll.com/2009/01/07/better-sampling/
		        vec3 dir = cosWeightedRandomHemisphereDirection( vNormal );

		        vec2 hituv; vec3 col; vec3 n;
		        float dist = castRay( vPosition, dir, hituv, col, n );
		        if( dist < DIST_MAX && dot( n, dir ) < 0. )
		        {
				    vec2 LM_UV_SCALE = LM_RES/iResolution.xy;
		            addLight += col * textureLod( iChannel0, hituv*LM_UV_SCALE, 0. ).xyz;
		        }
		    }
		}
	</script>
<script>
	var renderer = new THREE.WebGLRenderer();
	renderer.setClearColor(0x999999);
	// renderer.autoClear = false;
	var width = window.innerWidth;
	var height = window.innerHeight;
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize( width, height );
	
	var container = document.getElementById( 'container' );
	container.appendChild( renderer.domElement );

	var scene = new THREE.Scene();

	function genPlane(position,rotation, color){
		color = color | 0x999999;
		var geometry = new THREE.PlaneBufferGeometry( 4, 4 );
		var material = new THREE.MeshStandardMaterial( {
			color: color, 
			roughness: 0.9
		} );
		
		// console.log(geometry.attributes.uv);
		var plane = new THREE.Mesh( geometry, material );
		plane.position.set(position[0],position[1],position[2]);
		if(rotation)
			plane.rotation.set(rotation[0],rotation[1],rotation[2]);
		scene.add( plane );
		return plane;
	}

	var planes = [];
	planes.push(genPlane([-2, 0, 0],[0, Math.PI / 2, 0]));
	planes.push(genPlane([0, 0, -2]));

	var i = 0;
	var len = planes.length;
	//gen uv2
	for(var n = 0; n < len; n++ ){
		var plane = planes[n];
		var uv2 = [];
		//gen uv;
		var uv = plane.geometry.attributes.uv;
		var index = 0;
		for(var m = 0, length = uv.count; m < length ; m ++){
			//just scale x component
			uv2.push((i + uv.array[index]) / len);
			index++;
			uv2.push(uv.array[index]);
			index++;
		}
		plane.geometry.addAttribute( 'uv2', new THREE.Float32BufferAttribute( uv2, 2 ) );
		// plane.geometry.attributes.position.needsUpdate = true;
		i++;
	}

	var light = new THREE.PointLight( 0xffffff, 1, 100 );
	light.position.set( 0, 1, 0 );
	scene.add( light );



	var camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
	var controls = new THREE.EditorControls(camera, renderer.domElement);

	camera.position.set(0,0,10);
	function animate() {
		requestAnimationFrame( animate );
		renderer.render( scene, camera );
	}
	animate();

	function initScene(){
		var children = scene.children;
		console.log(children);
		var sceneShader = "";
		for(var i = 0, length = children.length; i < length; i++){
			var child = children[i];
			if(child.type == 'Mesh'){
				var temp = array(
					"Wall wall"+i+" = Wall( "" )";
				);
			}
		}

	}
	function genLightMap(){

		var quadCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

		var renderTarget1 = new THREE.WebGLRenderTarget( 512, 512, {
			minFilter: THREE.NearestFilter,
			magFilter: THREE.NearestFilter,
			format: THREE.RGBAFormat,
			type: THREE.FloatType,
			depthBuffer: false,
			stencilBuffer: false
		} );

		renderTarget1.texture.generateMipmaps = false;

		scene.overrideMaterial = new THREE.ShaderMaterial( {

			uniforms: {

			

			},

			vertexShader: document.getElementById( 'vertexShader' ).textContent,

			fragmentShader: document.getElementById( 'fragmentShader' ).textContent

		} );


		render.render(scene, quadCamera, renderTarget1);
}
</script>
</html>
